# Стэк

Стек – это структура данных, в которой элементы хранятся в порядке поступления. Его еще часто называют LIFO (Last-In/First-Out). Это отличает его от очереди, в которой элементы хранятся в порядке «первым пришел / первым обслужен» (FIFO).

![primer1](https://lh5.googleusercontent.com/EObIxhEydIeK35xf0dCpIsNcZqrYiaIc5B7MiNnnyly01JYxjkDs7oDBHtlN-z55jgpbfeK3wrFnyHknZ5Zq4rBoaKPQJ0B8S6eTlpm2uKESX4PKYcRZRTVXoz7PGmx2Rssi1BIe)

## Стэк вызовов

**Стек вызовов** (call stack) — стек, хранящий информацию для возврата управления из подпрограмм (функций) в программу или подпрограмму (при вложенных или рекурсивных вызовах).

![primer2](https://foxford.ru/uploads/tinymce_image/image/2803/%D1%81%D1%82%D0%B5%D0%BA_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%BE%D0%B22.png)

При вызове подпрограммы в стек заносится адрес возврата — адрес в памяти следующей инструкции приостанавливаемой программы, а управление передается подпрограмме. При последующем вложенном или рекурсивном вызове в стек заносится очередной адрес возврата и так далее.

При возврате из подпрограммы адрес возврата снимается со стека, и управление передается на следующую инструкцию приостановленной программы (или подпрограммы).

Предположим, имеется простая функция greet():

```
def greet(name):
    print f"Hello", +name+ "!"
    greet2(name)
    print("rdy to say goodbye")
    bye()

def greet2(name):
    print("how are you," + name + "?")

def bye():
    print("ok, bye!")
```

В программе используется вызов greet("Volodya"). Сначала компьютер выделяет блок памяти для этого вызова функции.

![Alt text](https://github.com/gireassen/my_library/blob/main/lib/groc_alg/stack/image.png?raw=true)

Затем эта память используется. Переменной *name* присваивается значение **Volodya**, оно должно быть сохранено в памяти. 

![Alt text](https://github.com/gireassen/my_library/blob/main/lib/groc_alg/stack/image-1.png?raw=true)

Каждый раз, когда вызываем фун-ю, компьютер сохраняет в памяти значение всех перерменных для этого вызова.
Далее выводится приветствие "***Hello Volodya!***", после чего следует второй вызов **greet2(Volodya)**.
И снова пк выделяет блок памяти для вызова функции.

![Alt text](https://github.com/gireassen/my_library/blob/main/lib/groc_alg/stack/image-2.png?raw=true)

Пк объединяет эти блоки в стек. Второй блок создаётся над первым. Мы выводим сообщение "***how are you, Volodya?***", после чего возвращаете управление из вызова функции. Когда это происходит, блок на верншине стека извлекается из него.

![Alt text](https://github.com/gireassen/my_library/blob/main/lib/groc_alg/stack/image-3.png?raw=true)

Теперь верхний блок относится к функции **greet()**, это означает, что вы вернулись к функции **greet()**. При вызове функции **greet2()** функция **greet()** еще <u>*не была завершена*</u>.
Здесь-то и скрывается истинный смысл Стэка вызовов:
<u>*Когда вы вызываете функцию, из другой функции, вызывающая функция приостанавливается в частично завершенном состоянии.*</u>
Все значения переменных этой функции остаются в памяти. А когда выполнение функции **greet2()** закончится, тогда веремся к функции **greet()** и продолжим её выполнение с того места, где оно прервалось.

![Alt text](https://github.com/gireassen/my_library/blob/main/lib/groc_alg/stack/image-4.png?raw=true)

Выводится сообщение "***rdy to say goodbye***", после вызывается функция **bye()**.

Блок для этой функции добавляетя на ввершину стека. Далее выводится сообщение "***ok, bye!***" с выходом из вызова функции.

![Alt text](https://github.com/gireassen/my_library/blob/main/lib/groc_alg/stack/image-5.png?raw=true)

Управление снова возвращается функции **greet()**.

### Вывод:
* Стек поддерживает две операции: занесение и извлечение элементов.
* Все вызовы функций сохраняются в стеке вызовов.
* Если стек вызовов станет очень большим, он займёт слишком много памяти.

[Назад](https://github.com/gireassen/my_library)