                                                # Основы асинхронности в Python #4: Генераторы и событийный цикл Round Robin
from time import time

def gen(s):                                                             # простой генератор
    '''
    gen - это простой генератор, который принимает на вход итерируемый объект s и 
    возвращает элементы этого объекта один за другим с помощью ключевого слова yield. 
    Генератор делает это по мере обращения к нему.
    '''
    for i in s:
        yield i

g = gen('ayrat')                                                        # функция-генератор отдаёт не только своё значение, которое он сгенерировал, но и контроль выполнения программы
                                                                        # и отдаёт его в то место, где была вызвана функция next
                                                                        # next(g)

def gen_filename():
    while True:
        pattern = 'file-{}.jpeg'
        t = int((time() * 1000))                                        #время в секундах
        yield pattern.format(str(t))

x = gen_filename() 
# функция next сдвигает выполнение программы до след-го yield

def gen_2():
    yield 1
    yield 2
    yield 3

def gen_3(s):                                                           # простой генератор
    '''
    gen_3 - это также простой генератор, который принимает целое число s и возвращает числа от 0 до s-1 
    одно за другим с помощью ключевого слова yield. 
    '''
    for i in range(s):
        yield i

def test():
    '''
    Функция test создает два объекта-генератора g1 и g2, используя функции gen и gen_3 соответственно. Затем эти генераторы добавляются в список tasks.\n
    Далее следует цикл while, который будет выполняться до тех пор, пока список tasks не станет пустым. В каждой итерации цикла происходит извлечение первого элемента списка tasks с помощью метода pop(0), что означает удаление элемента из списка. \n
    Затем выполняется попытка получить следующий элемент из извлеченного генератора с помощью функции next(task). Если элемент успешно извлекается, он выводится на печать с помощью функции print(i), а генератор добавляется в конец списка tasks. Таким образом, он будет продолжать выполняться в следующей итерации цикла.\n
    Если происходит исключение StopIteration, оно обрабатывается с помощью блока except StopIteration, который просто проходит мимо. Это исключение возникает, когда генератор заканчивает свою работу и больше не может вернуть новые значения.\n
    Таким образом, функция test обрабатывает генераторы g1 и g2, выводя их значения на печать, пока они не исчерпаны.\n
    '''
    g1 = gen('the_looppa')
    g2 = gen_3(10)

    tasks = [g1, g2]
    while tasks:                                                        # цикл будет работать, пока список не пуст
        task = tasks.pop(0)
        
        try:
            i = next(task)
            print(i)
            tasks.append(task)
        except StopIteration:
            pass

if __name__ =="__main__":
    test()

    print()

# генераторы - это функция, которая выполняет свою работу. их важно рассматривать с точки зрения передачи контроля выполнения команды.
# и в этот момент мы можем проделать люые действия с передаваемыми данными, или передавать куда-либо еще
# инструкций yield может быть несколько в одной функции-генераторе, и код после yield выполняется при след. вызове ф. next
